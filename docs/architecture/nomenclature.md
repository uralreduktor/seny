# Справочник номенклатуры

Документ описывает целевой справочник по принципам CPV: иерархическая структура
классов продукции и карточек с расширяемыми атрибутами. На этапе аналитики
фиксируем требования к модели данных, процессам и взаимодействию с текущими
модулями.

## 1. Доменный контекст

- **Цель** — единый эталонный источник характеристик изделий для тендеров, расчётов стоимости и ML.
- **Основные артефакты** — классы продукции (определяют схему атрибутов) и
  карточки номенклатуры (значения по конкретному объекту).
- **Ключевые сценарии**:
  - Быстро мапить тендерные позиции на эталонные карточки.
  - Поддерживать базовые цены и применимые методики расчёта.
  - Давать AI-компонентам нормализованный корпус знаний.
- **Связанные системы** — см. `[docs/architecture/domain-map.md](./domain-map.md)` для потоков данных и ролей.

### 1.1 Бизнес-кейсы и KPI

| Сценарий                       | Описание                                                  | KPI/метрика                                        |
| ------------------------------ | --------------------------------------------------------- | -------------------------------------------------- |
| Маппинг позиции → номенклатура | Инженер выбирает карточку на основе характеристик тендера | ≤ 5 минут на подбор; >90% повторного использования |
| Расчёт стоимости               | Методика автоматически подтягивается из класса            | Δ между эталонной и расчетной ценой < 10%          |
| Аналитика использования        | Команда видит, где применяются карточки                   | Полнота связей (позиции/тендеры) > 95%             |
| Управление изменениями         | Версионирование классов и карточек                        | SLA публикации изменений ≤ 2 дня                   |

## 2. Модель иерархии

### 2.1 Уровни классификатора

| Уровень              | Пример корпуса     | Код (формат)                            | Назначение                                                    |
| -------------------- | ------------------ | --------------------------------------- | ------------------------------------------------------------- |
| Разряд (Segment)     | `AA`               | `AA`                                    | Крупные группы (например, «Приводные механизмы»)              |
| Подразряд (Family)   | `AA.BB`            | `AA.BB`                                 | Уточняет тип (редукторы, мотор-редукторы)                     |
| Класс (Class)        | `AA.BB.CC`         | `AA.BB.CC`                              | Описывает класс продукции, содержит схему атрибутов           |
| Категория (Category) | `AA.BB.CC.DD`      | `AA.BB.CC.DD`                           | Уточняет конструктив (например, «червячный, одноступенчатый») |
| Карточка (Item)      | `AA.BB.CC.DD-XXXX` | Код категории + локальный идентификатор | Конкретный эталонный объект                                   |

Принципы:

- Глубина может расширяться (например, `EE` для модификации), код строится конкатенацией двухсимвольных сегментов.
- Классы и категории наследуют атрибуты родителя, но могут запрещать/добавлять поля.
- Уровни хранятся в одной таблице `nomenclature_nodes` с `type`, `code`,
  `parent_id`, `depth`. Карточки ссылаются на листовые узлы.

### 2.2 Версионирование структуры

- Любое изменение узла создаёт новую версию (`version`, `effective_from`, `effective_to`, `status`).
- Запрещено удалять узлы физически; используется `is_archived` и закрытие периода действия.
- Карточка хранит ссылку на версию узла, чтобы понимать контекст атрибутов.

## 3. Метамодель классов продукции

Каждый `class`/`category` имеет свой конфиг атрибутов. Рекомендуемый формат —
JSON Schema v2020-12, чтобы можно было валидировать значения карточек.

### 3.1 Структура описания атрибута

| Поле                    | Назначение                                                            |
| ----------------------- | --------------------------------------------------------------------- |
| `code`                  | Уникальный машинный код параметра (snake_case).                       |
| `title` / `description` | Человеко-читаемые названия.                                           |
| `data_type`             | `string`, `decimal`, `integer`, `boolean`, `enum`, `range`, `vector`. |
| `unit`                  | Ссылка на справочник единиц (ISO 80000).                              |
| `constraints`           | min/max, precision, regex, список допустимых значений.                |
| `required_level`        | `mandatory`, `recommended`, `optional`.                               |
| `visibility`            | Отражать ли поле на фронте, доступ для редактирования.                |
| `derived_from`          | Формула/указание на вычисляемое значение (например, отношение).       |
| `groups`                | Семантические блоки (механика, электрика, условия эксплуатации).      |

### 3.2 Наследование и сборка итоговой схемы

- Конфиг класса хранится в таблице `nomenclature_class_schema` и описывает
  **только отличия** конкретного узла относительно родителя.
- Итоговая JSON Schema формируется по цепочке узлов: `segment → … → category → node`.
  1. Берется опубликованная схема родителя.
  2. Подключаются пресеты (`INCLUDE` — добавляет блок атрибутов, `EXCLUDE` —
     удаляет из наследуемой схемы свойства, перечисленные в пресете).
  3. Применяются overrides текущего узла (`json_schema` уровня).
- Правила:
  - Свойства объединяются по ключу `properties`, значения глубоко мёрджатся.
  - `required` наследуется объединением; `EXCLUDE` удаляет поля и из `properties`, и из `required`.
  - Дополнительные секции (`definitions`, `allOf` и т.д.) копируются поверх по принципу deep-merge.
- SchemaRegistry кеширует финальную схему в Redis и инвалидацию выполняет событие публикации новой версии.

### 3.3 Журнал изменений

- Для каждой опубликованной версии вычисляется diff по ключам `properties`:
  - `added` — новые атрибуты {`code`: json}.
  - `removed` — массив кодов, удалённых из схемы.
  - `changed` — словарь `{code: {"old": {...}, "new": {...}}}`.
- Diff хранится в таблице `class_attribute_revisions` и доступен через API
  `/nomenclature/nodes/{node_id}/schemas/{version}/diff`.
- Используется в UI ревью для подсветки, а также в автоматических проверках на обратную совместимость.

### 3.4 Пресеты атрибутов

- Повторно используемые блоки (например, «электродвигатель», «редукторный блок») оформляются как отдельные пресеты.
- CRUD по пресетам доступен в API `/nomenclature/presets`.
- Подключение пресетов к схеме фиксируется в `class_schema_presets` с режимами:
  - `include` — добавляет свойства из пресета.
  - `exclude` — удаляет перечисленные свойства и делает их необязательными ниже по иерархии.
- Пресеты версионируются отдельно; при публикации схемы фиксируется id и версия пресета в diff.

## 4. Карточка номенклатуры

### 4.1 Обязательное ядро

| Группа              | Поля                                                                                                         |
| ------------------- | ------------------------------------------------------------------------------------------------------------ |
| Идентификация       | `id`, `code`, `canonical_name`, `node_id`, `node_version`, `status`                                          |
| Классификация       | `segment_code`, `family_code`, `class_code`, `category_code`, `manufacturer`, `standard_document`, `article` |
| Управление статусом | `lifecycle_status` (`draft`, `review`, `active`, `archived`), `effective_from/to`, `reason`                  |
| Связи               | `methodology_ids`, `synonym_ids`, `related_nomenclature_ids`, `position_usage_stats`                         |
| Ценообразование     | `base_price`, `cost_price`, `currency`, `price_source`, `price_confidence`, `price_valid_until`              |
| Метаданные          | `created_by`, `created_at`, `last_editor_id`, `last_reviewed_at`, `audit_log_id`                             |

### 4.2 Расширяемые значения

- `attributes_payload` — JSON, который валидируется схемой класса. Хранит фактические значения атрибутов.
- `files` — массив структур {`type`, `storage_key`, `hash`, `source`, `uploaded_at`}; связывается с MinIO через FileService.
- `ai_embeddings` — vector(1024/3072) для семантического поиска (опционально, но заложено в модель).
- `tags` — произвольный словарь дополнительных характеристик, которые не входят в схему узла. Пользователь может добавлять/удалять такие пары напрямую из UI карточки.

### 4.3 Lifecycle

1. `draft` — карточку создал инженер, проходят первичную валидацию.
2. `review` — ревьюер проверяет корректность характеристик и ссылок на методики.
3. `active` — карточка доступна для выбора в позициях. Любые изменения требуют создания новой версии (`version + 1`) и бизнес-обоснования.
4. `archived` — карточку нельзя привязать к новым позициям, но исторические связи
   сохраняются. Архивация требует указания причины (замена моделью, снято с
   производства и т.д.).

Статусы управляются через сервис `NomenclatureLifecycleService`, который:

- Проверяет, что актуальна версия класса и методик.
- Создаёт записи в `AuditLog` и отправляет уведомления заинтересованным ролям.

### 4.4 NomenclatureLifecycleService

- **Задачи:** централизованно валидировать переходы между статусами, применять
  изменения, фиксировать аудит и события.
- **Переходы:**
  - `draft → review` — доступны только после базовой валидации карточки.
  - `review → active` — требует успешного ревью, наличия методик и актуальной
    версии узла.
  - `review → draft` — отклонение с обязательным комментарием.
  - `active → archived` — требует указать причину и даты вывода из действия.
- **Проверки перед переходом:**
  - `node_version` карточки должен соответствовать последней опубликованной
    версии класса.
  - Для `review/active` обязательны `methodology_ids` и заполненный
    `attributes_payload`.
  - Для `archived` указывается `reason` и `effective_to`.
- **Аудит и события:**
  - Каждое изменение статуса создаёт запись `AuditLog` с действием
    `nomenclature_status_changed` и ссылкой на карточку (`entity_type =
nomenclature`).
  - Сервис публикует событие `nomenclature.lifecycle.changed`, чтобы
    downstream-системы (уведомления, аналитика) могли реагировать.
- **Bulk-сценарии:** пакетные операции используют те же проверки; ошибки
  возвращаются в виде списка нарушений по каждой карточке.

## 5. Управление данными и валидация

### 5.1 Процесс создания/изменения классов

1. Инициатор формирует предложение изменения (RFC) с описанием новых полей или ограничений.
2. Архитектор данных проверяет влияние (совместимость со старыми карточками, влияние на ML).
3. После утверждения генерируется новая версия класса: `class_version += 1`, фиксируются даты действия.
4. Триггерится задача по актуализации карточек (проверка обязательных полей, возможное авто-проставление).

### 5.2 Процесс создания карточки

1. Инженер выбирает категорию → система подгружает схему атрибутов.
2. Пользователь вводит значения; фронтенд валидирует по JSON Schema + бизнес-правилам (например, `power > 0`).
3. Бэкенд повторяет валидацию через Pydantic-модель (`Annotated[dict, JsonSchema(class_id)]`).
4. Карточка уходит в `review`; ревьюер может отклонить с комментарием или утвердить.

### 5.2.1 Registry схем

- Публикуемые JSON Schema узлов кешируются в Redis (`nomenclature:schema:{node_id}`)
  с TTL 1 час.
- При публикации новой версии (`/nodes/{node_id}/schemas/{version}/publish`)
  cache-инвалидация выполняется сразу.
- На бэкенде SchemaRegistry:
  - Загружает актуальную схему (из кеша или Postgres).
  - Компилирует Pydantic `TypeAdapter` с `AfterValidator`, который внутри
    вызывает `jsonschema.Draft2020-12`.
  - При ошибке возвращает список сообщений (`path: message`), которые
    проксируются в API (400).
- Валидация выполняется при создании и любом обновлении `attributes_payload`; без
  опубликованной схемы карточка не сохраняется.

### 5.3 Контроль качества

- **Неполные карточки** — отчёт по обязательным полям, SLA на заполнение.
- **Конфликты цен** — если базовая цена отличается от средней по позициям > X%, запускается пересмотр.
- **Дубли** — регулярный job, который ищет карточки с совпадающими ключами (`manufacturer + article`, similarity по embeddings).

### 5.4 Аудит и трассируемость

- Все изменения идут через `AuditService`, действие `nomenclature_updated`.
- Учитываются ссылки на исходные документы (тендер, письмо производителя).
- Для внешних ссылок хранится `source_reference` (URL, doc_id).

## 6. Архитектурные примечания

- **Хранение схем**: таблица `nomenclature_class_schema` (`class_id`, `version`,
  `json_schema`, `status`).
- **API**: планируем namespace `/api/v1/nomenclature/*` (карточки) и
  `/api/v1/nomenclature/classes/*`.
- **Кэширование**: популярные классы кешируются в Redis (schema + пресеты) с
  инвалидацией по событию `class_version_published`.
- **Поиск**: комбинация `pg_trgm` по названию и `pgvector` по embeddings для
  полнотекстового + семантического поиска. Эндпоинт `/nomenclature/cards`
  принимает `search_mode` (`text`, `semantic`, `combined`) и возвращает
  `search_confidence`. Текстовый режим ускорен GIN индексом
  `ix_nomenclatures_canonical_name_trgm`, семантический использует embedding
  OpenAI `text-embedding-3-large` (3072d) и cosine distance (`pgvector`).
- **Интерфейс**: дерево классификатора слева, детальная форма справа; атрибуты
  группируются по блокам.

## 7. Следующие шаги реализации

1. **ERD** — подготовить диаграммы в `docs/architecture/diagrams/nomenclature_ERD.mmd`.
2. **API контракты** — описать схемы в `docs/development/api/nomenclature.yaml` (OpenAPI).
3. **Прототип UI** — сделать Figma/описание интерфейса в `docs/functional/nomenclature_ui.md`.
4. **Миграции** — спроектировать таблицы (`nomenclature_nodes`,
   `nomenclature_cards`, `nomenclature_class_schema`,
   `nomenclature_attribute_presets`, `nomenclature_card_versions`).

Документ следует актуализировать при любых изменениях структуры данных или процессов.

## 8. Статус реализации (ноябрь 2025)

### 8.1 Сделано

- **Классификатор узлов**: дерево в UI строится из `/nomenclature/nodes`, поддерживает создание/редактирование/архивирование, а также выбор узла для карточек.
- **Версионирование схем**: реализованы драфты, публикация, diff, подключение пресетов и автозаполнение полей из пресетов (UI + API `/nodes/{id}/schemas` и `/publish`). Исправлена сериализация пресетов в ответе API (теперь возвращаются полноценные `AttributePreset`).
- **Редактор карточек**:
  - атрибуты рендерятся из актуальной JSON Schema, лейблы берутся из `description`;
  - добавлен мультиселект для полей типа `array`;
  - реализованы пользовательские поля `tags` (в UI блок «Дополнительные поля»);
  - поля «Тип» и «Категория» сохраняются и отображаются в таблице, сериализуются через backend.
- **Поиск**: поддерживаются режимы `text/semantic/combined`, в ответе отображается `search_confidence`.
- **Инфраструктура**: SchemaRegistry кеширует опубликованные схемы, Redis-инвалидация выполняется при публикации; backend логи очищены от ошибок сериализации (ResponseValidationError).

### 8.2 В работе / осталось

- Описать схемы API номенклатуры в `docs/development/api/nomenclature.yaml` и синхронизировать с текущими эндпоинтами.
- Обновить ERD (`docs/architecture/diagrams/nomenclature_ERD.mmd`) с учётом новых таблиц (`class_schema_presets`, `class_attribute_revisions`, `nomenclature_card_versions`).
- Реализовать процесс ревью/approval на фронте (статусы карточек пока меняются только через API).
- Автоматизировать миграции для дополнительных полей (tags) и обновить `docs/development/database_migrations.md` (файл пока отсутствует).
