План эволюционного развития
Версионирование узлов без ломки схемы ✅
Ввести таблицу nomenclature_node_versions (id, node_id, version, effective_from/to, payload diff).
При PATCH создавать новую версию записи и закрывать предыдущую (effective_to = now), а сам nomenclature_nodes держать как “живой” pointer на актуальную версию.
Архивировать через soft close: выставляем status = archived, effective_to, но историю не теряем. API остаётся прежним, но возвращает данные из актуальной версии.
Расширение метамодели классов
Добавить class_attribute_revisions + сервис, который при публикации схемы фиксирует diff с предыдущей.
Реализовать наследование: при сборке схемы для категории подтягиваем json_schema родителя + применяем overrides из текущего уровня и подключаем пресеты (ClassSchemaPreset уже есть, нужно только endpoint для CRUD и механизм merge).
На бэкенде использовать Pydantic TypeAdapter/Annotated для валидации attributes_payload по результирующей схеме.
Обязательное ядро карточки ✅
Расширить модель Nomenclature кодами сегмента/класса, полями price_confidence, related_nomenclature_ids (ARRAY), audit_log_id.
При создании карточки вычислять коды из узла (propagation) и хранить в новых колонках. Это позволит не ломать существующий фронт.
Сервис жизненного цикла
Выделить NomenclatureLifecycleService, который:
Проверяет актуальность node_version и наличие методик (при переходе в review/active).
Создаёт запись в AuditLog (используем существующий сервис аудита) и шлёт доменное событие nomenclature_status_changed.
Обновить REST (cards/{id}/lifecycle) так, чтобы он делегировал новому сервису; текущие сценарии фронта не изменятся.
Валидация атрибутов
Реализовать helper SchemaRegistry, который кеширует опубликованные схемы в Redis; при создании/обновлении карточки получаем схему и валидируем attributes_payload через TypeAdapter.
Фронт по-прежнему работает с JSON Schema, но теперь сервер гарантированно отклоняет неконсистентные данные.
Поиск и статистика
Добавить GIN индекс pg_trgm на canonical_name и миграцию pgvector уже подключена — поэтому достаточно реализовать опциональный параметр search_mode=semantic, который использует similarity по ai_embedding.
В NomenclatureCardService.list_cards постепенно расширить фильтры, не меняя сигнатуру существующих параметров.
UI обновления
На текущей странице добавить левую колонку с деревом (/nomenclature/nodes) и панель деталей карточки; можно внедрить постепенно:
Дерево + фильтр node_id.
Детальная форма, которая использует схему для динамических атрибутов.
Приоритет внедрения
Версионирование узлов + хранение кодов в карточках — критично для консистентности и не требует изменений фронта.
Сервис lifecycle + аудит — обеспечивает контроль статусов.
Валидация атрибутов с кешированием схем — блокирует невалидные данные и готовит почву для UI форм.
Расширение схем (наследование, diff, пресеты) — сложнее, но можно внедрять частями: сначала CRUD пресетов и привязка, потом журнал diff.
Поиск и pg_trgm/pgvector оптимизации — независимый шаг, улучшает UX.
UI дерево/форма — после того как сервер возвращает нужные данные.
Сообщи, с какого блока начнём — подготовлю детальный план и изменения по бэкенду/фронту.

Следующие этапы
Сервис жизненного цикла и аудит ✅
• Добавлен `NomenclatureLifecycleService` с проверками переходов, аудитом и событиями.
• Обновлены сервисы карточек, API и документация; введены unit-тесты и миграции для `audit_logs`.
1. Проектирование
   • В docs/architecture/nomenclature.md зафиксировать контракт `NomenclatureLifecycleService` (входы, проверки, события).
   • Определить роли и права (какие статусы доступно переключать).
2. Backend
   • Создать сервис `NomenclatureLifecycleService` в modules/pricing_kb_ai/services/.
   • Перенести логику смены статуса из `NomenclatureCardService.change_lifecycle` в новый сервис, добавить проверки актуальности схемы/методик и заполненность обязательных полей.
   • Интегрировать `AuditLog` (через существующий модуль) и публикацию события `nomenclature_status_changed`.
   • Добавить unit-тесты на сценарии `draft→review`, `review→active`, `active→archived`.
3. API / Frontend
   • Обновить эндпоинты `/nomenclature/cards/{id}/lifecycle` и bulk-операции, чтобы они вызывали сервис и возвращали сообщения об ошибках.
   • На фронте отобразить статусы и ошибки ревьюера (минимальные изменения UI).

Валидация атрибутов и кеширование схем ✅
• SchemaRegistry (Redis cache, TypeAdapter + jsonschema) внедрён, вызовы интегрированы в create/update, API возвращает 400 при ошибке.
1. Redis
   • Добавить конфиг для подключения (использовать уже имеющийся Redis инстанс, добавить секцию в settings).
2. Schema Registry
   • Реализовать компонент, который загружает опубликованную схему узла (с учётом наследования) и кеширует её в Redis.
   • Обеспечить инвалидацию по событию публикации новой версии.
3. Валидация
   • Добавить TypeAdapter/Pydantic-модель, валидирующую `attributes_payload` по JSON Schema (использовать Annotated + custom validator).
   • Применять валидатор в `NomenclatureCardService.create/update`.
4. Тесты
   • Набор unit-тестов на успешную и неуспешную валидацию, проверку кеша и инвалидации.

Расширение схем и журнал изменений ✅
• CRUD пресетов, наследование и diff внедрены: SchemaRegistry мёрджит родителя + пресеты + overrides, diff доступен в `/nomenclature/nodes/{node}/schemas/{version}/diff`.
1. CRUD пресетов
   • Добавить endpoint `/nomenclature/presets` для управления `NomenclatureAttributePreset`.
   • Обеспечить подключение пресетов к схемам с режимами INCLUDE/EXCLUDE (уже в модели).
2. Наследование
   • При построении итоговой схемы объединять json_schema родителя, пресетов и текущего узла; предусмотреть механизм overrides и скрытия полей.
3. Журнал
   • Ввести таблицу `class_attribute_revisions` (schema_id, version, diff_payload, author_id).
   • Фиксировать diff при публикации версии.
4. Документация
   • Обновить `docs/architecture/nomenclature.md` (раздел 3) и `docs/development/api/nomenclature.yaml`.

Поиск и аналитика
Поиск ✅
• Добавлен GIN индекс `ix_nomenclatures_canonical_name_trgm` и активирован `pg_trgm`.
• Эндпоинт `/nomenclature/cards` поддерживает `search_mode` (`text`, `semantic`, `combined`) и возвращает `search_confidence` (pgvector + OpenAI embeddings).
• UI позволяет выбирать режим поиска и показывает score для каждой карточки.
Аналитика (в работе)
1. Backend
   • Подсчитывать статистику использования (например, через materialized view или job).
2. Тесты / Мониторинг
   • Написать интеграционный тест для текстового и семантического поиска (использовать фикстуры).
   • Добавить метрику времени ответа и количества документов в результатах.

UI дерево и форма
1. Фронтенд ✅
   • Дерево классификатора подключено к `/nomenclature/nodes`, фильтр по `node_id` и загрузка схемы реализованы.
   • Диалог карточки строит форму по JSON Schema и сохраняет `attributes_payload` через `/nomenclature/cards`.
   • Реализован полный CRUD для узлов: создание дочерних узлов, редактирование (`PATCH /nodes/{id}`) и архивирование (`DELETE /nodes/{id}`) прямо из UI.
   • Редактор схемы работает с контролируемым списком полей (toggle, тип, enum, default). JSON формируется автоматически и отображается превью перед сохранением.
2. UX / Документация ✅
   • Сценарий и UX заметки описаны в `docs/functional/nomenclature_ui.md`.
3. Тестирование ✅
   • Интеграционный сценарий (`frontend/src/components/__tests__/NomenclatureAttributesForm.test.tsx`) покрывает ввод и очистку атрибутов.

Дальнейшие шаги
• После завершения каждого этапа обновлять документацию (`docs/architecture`, `docs/development/api`) и CHANGELOG.
• Перед выпуском — прогонить полный набор тестов и убедиться, что build фронтенда попадает в `frontend/dist`.
